

/*

VER 2.0  2017-12-24
取消背板定时，采样CDR提取系统时钟

VER 1.0  2016-02-26
与背板连接信号的处理
A面和B面信号分别连接主控板A和主控板B，由OnPos、ErrFree、ActStatus以及本板接收的信号决定选择A面或B面
背板时钟采用77.76MHz（串行速率），并行位宽为12位，0-3为信令专用，4-11为业务专用，并行速率为77.76/12(MHz)
mclk77m作为本地的锁相参考时钟，鉴相时钟为77.76/12(MHz)
定时计数器：位宽定时(0-11)/行定时(0-89)/列定时(0-8)/帧定时(0-3)
本地定时同步方法：由本地时钟采样接口定时计数器（有效）数值变化，并据此置位(同步)本地计数器

*/
	
	
	
`define FS 82				// 定义本卡帧与背板帧信号的相位偏差
	
	
module BACK_V22
(	
	input rst,
	input CntClr,
	input ck19m,
	input [1:0] OnPos,
	input [1:0] ErrFree,
	input [1:0] ActStatus,
	
	output [1:0] ud,			// 发往背板的2路串行信号
	input [1:0]  dd,			// 来自背板的2路串行信号
	
	input [11:0] udp,			// 发往背板的12位并行信号
	output reg [11:0] ddp,		// 来自背板的12位并行信号
	
	output sclk77m,			// 系统时钟
	output sclk77m_12,
	
	input pLnkLoop,			// 单板自环
	input [11:0] LnkLoop,		// 链路环回控制信号
	
	output reg SwCtl,			// 0：选择A路，1：选择B路
	output reg sLocked,			// 系统锁定指示
	
	output reg BackErr,			// 1=接收帧误码（仅当前主用CL）
	output reg BackSync,		// 1=接收帧同步（仅当前主用CL）
	

	output reg [7:0] BackErrCnt,
	output reg [7:0] BackSyncCnt,
	output reg [7:0] SwCtlCnt,
	output reg [7:0] sLockedCnt,	



	output [4:0] uCulSect,
	output [4:0] uTs,
	output uPlTug2,
	output [4:0] dCulSect,
	output [4:0] dTs,
	output dPlTug2,
	
	output UpFs8k,			// 上行合成帧定位信号
	output DpFs8k			// 下行合成帧定位信号   LnkRcv
);	



//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

	reg [1:0] OnPos_r;
	reg [1:0] OnPos_rr;
	reg [1:0] ErrFree_r;
	reg [1:0] ErrFree_rr;
	reg [1:0] ActStatus_r;
	reg [1:0] ActStatus_rr;		
	wire sel_a;
	wire sel_b;

	
	
	// 时钟域转换
	always @ (posedge sclk77m or posedge rst)
		if (rst) begin
			OnPos_r 		<= 2'b11;
			ErrFree_r 		<= 2'b11;
			ActStatus_r 	<= 2'b10;
		end
		else	begin
			OnPos_r 		<= OnPos;
			ErrFree_r 		<= ErrFree;
			ActStatus_r 	<= ActStatus;
			OnPos_rr 		<= OnPos_r;
			ErrFree_rr 	<= ErrFree_r;
			ActStatus_rr 	<= ActStatus_r;
		end	
		
	
	assign sel_a =  (OnPos_rr==2'b10) | 																// CL-A在位；CL-B不在位
			((OnPos_rr==2'b00) & (ErrFree_rr==2'b10)) |				// CL-A/B在位；CL-B故障
			((OnPos_rr==2'b00) & (ErrFree_rr==2'b00) & (ActStatus_rr==2'b10));		// CL-A/B在位；CL-A/B无故障；CL-A当前主用；CL-B当前备用
							
	assign sel_b =  (OnPos_rr==2'b01) | 																// CL-B在位；CL-A不在位
			((OnPos_rr==2'b00) & (ErrFree_rr==2'b01)) |				// CL-A/B在位；CL-A故障
			((OnPos_rr==2'b00) & (ErrFree_rr==2'b00) & (ActStatus_rr==2'b01));		// CL-A/B在位；CL-A/B无故障；CL-B当前主用；CL-A当前备用
	
	
	// 选收控制信号
	always @ (posedge sclk77m or posedge rst)
		if (rst) 			SwCtl <= 0;
		else
			if (sel_a) 		SwCtl <= 1'b0;	// 选择A通道接收
			else if (sel_b)	SwCtl <= 1'b1;	// 选择B通道接收

			
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// 下行信号时钟提取+信号再生处理


	(*keep*)wire m_din;
	assign m_din = (SwCtl)? dd[1] : dd[0];		// 选取时钟提取参考源
	
	

	wire c0, c1, c2, c3, c4;
	wire dck;
	wire dout;
	
	CDR77m CDR77m_inst  // 从m_din信号中提取时钟c0-c4，锁定频率
	(
		.din	(m_din) ,		// 由c2时钟取样
		.ck19m	(ck19m) ,		// 本地时钟
		.dout	(dout) ,		// 数据输出，与c4对齐
		.dck	(dck) ,		// dck=c4,
		.c0	(c0) ,		// 锁相环输出时钟
		.c1	(c1) ,		// 锁相环输出时钟
		.c2	(c2) ,		// 锁相环输出时钟
		.c3	(c3) ,		// 锁相环输出时钟
		.c4	(c4) 		// 锁相环输出时钟
	);


	

	(*keep*)wire [1:0] rdo;
	(*keep*)wire [11:0] prd[0:1];		
	(*keep*)wire [1:0] SyncSta;	
	(*keep*)wire [1:0] b1_err;
	(*keep*)wire [3:0] TimWord[0:1];	
	(*keep*)wire [6:0] TimCul[0:1];	
	(*keep*)wire [3:0] TimRow[0:1];
	reg [6:0] TimCul_r[0:1];
	reg [1:0] TimSetI;
	
	
	genvar i;
	generate for(i = 0; i < 2; i = i + 1) begin: GEN_LOOP
	
		pll_pd pll_pd_inst // dd[i]信号再生，补偿了相位延时
		(
			.rst	(rst),
			.din	(dd[i]),
			.c0	(c0),
			.c1	(c1),
			.c2	(c2),
			.c3	(c3),
			.c4	(c4),
			.dout	(rdo[i]),
			.cs	(),
			.nd	()
		);	

		Rcv_bb Rcv_bb_inst // 接收帧同步
		(
			.rst		(rst),
//			.din		(rdo[i]),
			.din		({dout,dout}),
			.dck		(dck),
			.prd		(prd[i]),
			.SyncSta		(SyncSta[i]),
			.TimWord		(TimWord[i]),
			.TimCul		(TimCul[i]),
			.TimRow		(TimRow[i]),
			.TimFrm		(),	
			.b1_err		(b1_err[i])	
		);		
		
		
		always @ (posedge sclk77m or posedge rst)	// 设定参照时隙 TimSetI，由参数FS确定
			if (rst) begin
				TimCul_r[i] <= 0;
				TimSetI[i] <= 1'b0;
			end
			else if (sTimWord==5) begin
				TimCul_r[i] <= TimCul[i]; // 防止信号中断

				if (TimRow[i]==8 & TimCul_r[i]==`FS-1 & TimCul[i]==`FS) 		TimSetI[i] <= 1'b1;
				else							TimSetI[i] <= 1'b0;				
			end		
		
		
	end
	endgenerate

	
	
	wire sTimSetI;
	assign sTimSetI = (SwCtl)? TimSetI[1] : TimSetI[0]; // 系统定时置位信号的来源选择：A或B		
	
	reg [7:0] sTimSetI_r;
	always @ (posedge sclk77m or posedge rst) 
		if (rst)  			sTimSetI_r[7:0] <= 0;
		else if (sclk77m_12) 	sTimSetI_r <= {sTimSetI_r[6:0], sTimSetI};	
	
	
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
	
		// 产生锁相环以及定时参考
		
		
	wire m_TimWord3;
	assign m_TimWord3 = (SwCtl)? TimWord[1][3] : TimWord[0][3];		// 选取相位锁定参考源
		
		
	(*keep*)reg [7:0] Phase_sr;
	always @ (posedge sclk77m or posedge rst) 	// 连续鉴相结果存储，取样位宽边界
		if (rst) 			Phase_sr[7:0] <= 0;
		else if (sclk77m_12) 	Phase_sr[7:0] <= {Phase_sr[6:0], m_TimWord3};
			
	
	(*keep*)wire DataSlower, DataFaster;
	assign DataSlower = &Phase_sr[2:0];		// 3次取样为全“1”，视为锁相时钟过快
	assign DataFaster = ~(|Phase_sr[2:0]);	// 3次取样为全“0”，视为锁相时钟过慢
		
		
	wire phasestep, phaseupdown;
	assign phasestep 	 = (DataSlower | DataFaster) & phasedone;	// 启动调相
	assign phaseupdown =  DataSlower;	// 调相方向	
	
	
	wire phasedone, locked;
	pll77m_1		pll77m_1_inst (
		.areset 				( rst ),
		.inclk0 				( ck19m ),
		.phasecounterselect 		( 3'b000 ),
		.phasestep 			( phasestep ),
		.phaseupdown 			( phaseupdown ),
		.scanclk 				( sclk77m ),
		.c0 				( sclk77m ),
		.locked 				( locked ),
		.phasedone 			( phasedone )
		);		
	
	
	
	wire LosPhase, GetPhase;
	assign LosPhase = &Phase_sr[7:0]	| ~(|Phase_sr[7:0]); // 连续8次鉴相结果为全“1”或全“0”，视为相位丢失
	assign GetPhase = ~(&Phase_sr[4:0]) & (|Phase_sr[4:0]); // 连续5次鉴相结果不为全“1”或全“0”，视为已捕获相位
	

	always @ (posedge sclk77m or posedge rst) 	// 锁相状态指示，输出
		if (rst) 						sLocked <= 0;
		else
			if (sclk77m_12)
				if (~locked) 			sLocked <= 0;
				else
					if (LosPhase) 		sLocked <= 0;
					else if (GetPhase) 		sLocked <= 1;			
	
	
	reg sLocked_r;
	always @ (posedge sclk77m or posedge rst) 	// 锁相历史状态
		if (rst) 				sLocked_r <= 1'b1;
		else if (CntClr)			sLocked_r <= 1'b1;
		else if (!sLocked)			sLocked_r <= 1'b0;			
	
	
	
	
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------	
// 下行信号			
	
	wire [11:0] ddpx;	
	reg [11:0] ddpx_r;	
	
	assign ddpx = (pLnkLoop)? LoopDdp : (SwCtl)? prd[1] : prd[0];
	
	always @ (posedge sclk77m or posedge rst) 
		if (rst) 			ddpx_r <= 0;
		else if (sTimWord==5) 	ddpx_r <= ddpx;	// 	
	
	always @ (posedge sclk77m or posedge rst) 
		if (rst) 			ddp <= 0;
		else if (sTimWord==11) 	ddp <= ddpx_r;	// 		
	
	
	
	
	
	reg [1:0] dMfNum;
	always @ (posedge sclk77m or posedge rst) // 
		if (rst) 					dMfNum <= 0;
		else if (sTimWord==11) 	
			if (dTimeTs && ddp[1:0]==0)		dMfNum <= 0;
			else if (sTimSetI_r[7])		dMfNum <= dMfNum + 1'b1;	
	
	
	reg [1:0] uMfNum;
	always @ (posedge sclk77m or posedge rst) // 
		if (rst) 					uMfNum <= 0;
		else if (sTimWord==11) 	
			if (dTimeTs && ddp[1:0]==0)		uMfNum <= 0;
			else if (sTimSetI_r[0])		uMfNum <= uMfNum + 1'b1;	
	
	
		
	// udp_ins比ddp提前6个sclk77m_12周期，延迟，用于自环
		
	reg [11:0] udp_ins_r[0:5];	
	
		always @ (posedge sclk77m or posedge rst) 
		
			if (rst)  begin
			
				udp_ins_r[0] <= 0;
			
				udp_ins_r[1] <= 0;
			
				udp_ins_r[2] <= 0;
			
				udp_ins_r[3] <= 0;
				udp_ins_r[4] <= 0;
				udp_ins_r[5] <= 0;		
			end	
		
			else if (sclk77m_12)  begin
			
				udp_ins_r[0] <= udp_ins;
			
				udp_ins_r[1] <= udp_ins_r[0];
			
				udp_ins_r[2] <= udp_ins_r[1];
			
				udp_ins_r[3] <= udp_ins_r[2];
				udp_ins_r[4] <= udp_ins_r[3];
				udp_ins_r[5] <= udp_ins_r[4];
			end	

	

	
	(*keep*)wire [11:0] LoopDdp;
	
	assign LoopDdp = udp_ins_r[5];	
	
	
	(*keep*)wire sSyncSta, sb1_err;
	
	assign sSyncSta = (SwCtl)? SyncSta[1] : SyncSta[0]; // 系统定时置位信号的来源选择：A或B		
	assign sb1_err = (SwCtl)? b1_err[1] : b1_err[0]; 
	
	assign BackErr = sb1_err;
	assign BackSync = sSyncSta;  // 定义修改，作为主用接收同步状态
	
	
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 上行信号合成
	
	
	// 并串转换+扰码，同时发往背板a、b路	
	
	
	
	assign ud[0] = ud_sr[11];
	assign ud[1] = ud_sr[11];		
	
	
	reg [11:0] ud_sr;
	
	always @ (posedge sclk77m or posedge rst) 			
		if (rst) 			ud_sr[11:0] <= 0;
		else if (sclk77m_12) 	ud_sr[11:0] <= {udp_ins[11] ^ (d_ds && d_scrb_en), udp_ins[10:0]};
		else 			ud_sr[11:0] <= {ud_sr[10]   ^ (d_ds && d_scrb_en), ud_sr[9:0], 1'b1};

		
		
//-----------------------------------------------------------------------		
// 产生扰码信号d_ds，注意与信号的相位对齐!!!!!!		
		

	reg scrb_en;
	reg d_scrb_en;
	reg d_init;
	wire d_ds;
				
				
	always @ (posedge sclk77m or posedge rst) 
		if (rst)					scrb_en <= 1'b0;
		else if (uTimeTs && sTimWord==9) 		scrb_en <= 1'b0;
		else if (uTimeTs_r[5] && sTimWord==9) 	scrb_en <= 1'b1;


	always @ (posedge sclk77m or posedge rst) 
		if (rst)		d_scrb_en <= 1'b0;
		else 		d_scrb_en <= scrb_en;
		
	
	always @ (posedge sclk77m or posedge rst) 
		if (rst)		d_init <= 1'b1;
		else 		d_init <= uTimeTs_r[5] && sTimWord==8;
	
	
	
	scrb  u_scrb_inst
	(
		.rst		(rst),
		.clk		(sclk77m),
		.scrb_en		(scrb_en),
		.init		(d_init),
		.ds		(d_ds)
	);			
		
//-----------------------------------------------------------------------		
// 误码检测字段计算


	reg [11:0] b1;
	reg [11:0] b1_r;
	
	always @ (posedge sclk77m or posedge rst) 
		if (rst) begin
			b1 	<= 12'b0;
			b1_r 	<= 12'b0;
		end
		else if (sclk77m_12)
			if (uTimeTs) begin
				b1 	<= 12'b0;
				b1_r 	<= b1 ^ udp_ins;
			end
			else begin
				b1 	<= b1 ^ udp_ins;
				b1_r 	<= b1_r;
			end	
	
//-----------------------------------------------------------------------		
	
	reg [11:0] udp_ins;
	
	always @ (*)
//		if (uTimeTs)				udp_ins = {sSyncSta, 11'h7ff};// 空闲
		if (uTimeTs)				udp_ins = {!sSyncSta, 11'h7ff};// 空闲
		else if (uTimeTs_r[0])			udp_ins = b1_r;// 插入误码检测字段
		else if (uTimeTs_r[1])			udp_ins = 12'h9fa;// 插入同步头
		else if (uTimeTs_r[2])			udp_ins = 12'h928;
		else if (uTimeTs_r[3])			udp_ins = 12'hfff;// 备用，可用于在CL板和IO板之间传输数据
		else if (uTimeTs_r[4])			udp_ins = 12'hfff;// 备用，可用于在CL板和IO板之间传输数据		
		else							udp_ins = udp[11:0];
	
	
//-----------------------------------------------------------------------		
	
	
	always @ (posedge sclk77m or posedge rst)			
		if (rst)				BackErrCnt <= 0;
		else if (CntClr)			BackErrCnt <= 0;
		else if ((BackErrCnt<255) & sclk77m_12 & dTimeTs & BackErr)		 
						BackErrCnt <= BackErrCnt + 1'b1;
	
	
	
	reg nTimeDa_r;
	always @ (posedge sclk77m or posedge rst)			
		if (rst)		nTimeDa_r <= 0;
		else 		nTimeDa_r <= BackSync;
	
	always @ (posedge sclk77m or posedge rst)			
		if (rst)			BackSyncCnt <= 0;
		else if (CntClr)		BackSyncCnt <= 0;
		else if ((BackSyncCnt<255) && sclk77m_12 && dTimeTs && nTimeDa_r && !BackSync)		 
					BackSyncCnt <= BackSyncCnt + 1'b1;

								
								
	always @ (posedge sclk77m or posedge rst)			
		if (rst)			SwCtlCnt <= 0;
		else if (CntClr)		SwCtlCnt <= 0;
		else if ((SwCtlCnt<255) & ((SwCtl & sel_a) | (~SwCtl & sel_b)))	 
					SwCtlCnt <= SwCtlCnt + 1'b1;
									
								
	always @ (posedge sclk77m or posedge rst)			
	if (rst)				sLockedCnt <= 0;
	else if (CntClr)			sLockedCnt <= 0;
//	else if ((sLockedCnt<255) & sLocked & ~sLosPhase)	
	else if ((sLockedCnt<255) & sLocked & LosPhase)	
					sLockedCnt <= sLockedCnt + 1'b1;								
								

//-----------------------------------------------------------------------		
	
	
	
	
	
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
//-----------------------------------------------------------------------		
		
		
	wire uTimSetI;
	wire dTimSetI;
		
//	assign uTimSetI = sTimSetI_r[0] && uMfNum==3;	
//	assign dTimSetI = sTimSetI_r[7] && dMfNum==3;			
		
	assign uTimSetI = uFrm==3 && uRow==8 && uCulPhs==4 && uCulSect==20;		
	assign dTimSetI = uTimSetI_r[6];
		
	reg [6:0] uTimSetI_r;
	always @ (posedge sclk77m or posedge rst) 
		if (rst)  			uTimSetI_r <= 0;
		else if (sclk77m_12) 	uTimSetI_r <= {uTimSetI_r[5:0], uTimSetI};		
		
		
//-----------------------------------------------------------------------		
		
	assign UpFs8k = uRow==8 && uCulPhs==4 && uCulSect==19 && sclk77m_12;						// 上行合成帧定位信号
	assign DpFs8k = dRow==8 && dCulPhs==4 && dCulSect==20 && sclk77m_12;						// 下行合成帧定位信号   LnkRcv
		
//-----------------------------------------------------------------------		


	assign sclk77m_12 = sTimWord==11;			
	
	reg [3:0] sTimWord;
	always @ (posedge sclk77m or posedge rst)		
		if (rst) 	sTimWord <= 0;
		else	sTimWord <= (sTimWord==11)? 4'b0 : sTimWord + 4'b1;
		
		
		
	wire uTimeTs, dTimeTs;	
	
	assign uTimeTs = uRow==0 && uCulPhs==0 && uCulSect==0;		
	assign dTimeTs = dRow==0 && dCulPhs==0 && dCulSect==0;
		
		
		
	reg [5:0] uTimeTs_r, dTimeTs_r;	
		
		
	always @ (posedge sclk77m or posedge rst) 
		if (rst)  			uTimeTs_r[5:0] <= 0;
		else if (sclk77m_12) 	uTimeTs_r <= {uTimeTs_r[4:0], uTimeTs};		
		
		
	always @ (posedge sclk77m or posedge rst) 
		if (rst)  			dTimeTs_r[5:0] <= 0;
		else if (sclk77m_12) 	dTimeTs_r <= {dTimeTs_r[4:0], dTimeTs};		
	
	

	
	(*keep*)wire uIncCulPhs, uIncRow, uIncFrm, uIncTs; 
	(*keep*)wire uResetCulSect, uResetCulPhs, uResetRow, uResetFrm, uResetTs;
	(*keep*)wire uTug2head, uTu12Head, uTu12End; //uPlTug2;
	//(*keep*)wire [4:0] uCulSect;
	(*keep*)wire [2:0] uCulPhs;
	(*keep*)wire [3:0] uRow;
	//(*keep*)wire [4:0] uTs;
	(*keep*)wire [1:0] uFrm;	

	SdhBaseTiming uSdhBaseTiming_inst
	(
		.ck77m		(sclk77m),						
		.sclk77m_12	(sclk77m_12),		
		.rst		(rst),					
//		.TimSetI		(uTimSetI), 
		.TimSetI		(sTimSetI_r[0] && uMfNum==3), // 与背板同步入口
		
		
		.IncCulPhs	(uIncCulPhs),			
		.IncRow		(uIncRow),					
		.IncFrm		(uIncFrm),			
		.IncTs		(uIncTs),
		
		.ResetCulSect	(uResetCulSect),	
		.ResetCulPhs	(uResetCulPhs),		
		.ResetRow	(uResetRow),		
		.ResetFrm		(uResetFrm),		
		.ResetTs		(uResetTs),
		
		.Tug2head	(uTug2head),				
		.Tu12Head	(uTu12Head),				
		.Tu12End		(uTu12End),		
		.PlTug2		(uPlTug2),
		
		.CulSect		(uCulSect),				
		.CulPhs		(uCulPhs),	
		.Ts		(uTs),
		.Row		(uRow),					
		.Frm		(uFrm)					
	);
	
	
	
	
	(*keep*)wire dIncCulPhs, dIncRow, dIncFrm, dIncTs; 
	(*keep*)wire dResetCulSect, dResetCulPhs, dResetRow, dResetFrm, dResetTs;
	(*keep*)wire dTug2head, dTu12Head, dTu12End; //dPlTug2;
	//(*keep*)wire [4:0] dCulSect;
	(*keep*)wire [2:0] dCulPhs;
	(*keep*)wire [3:0] dRow;
	//(*keep*)wire [4:0] dTs;
	(*keep*)wire [1:0] dFrm;	

	SdhBaseTiming dSdhBaseTiming_inst
	(
		.ck77m		(sclk77m),						
		.sclk77m_12	(sclk77m_12),		
		.rst		(rst),					
		.TimSetI		(dTimSetI),   			// BACK模块产生，比背板定时信号提前3个sclk77m_12周期
		
		.IncCulPhs	(dIncCulPhs),			
		.IncRow		(dIncRow),					
		.IncFrm		(dIncFrm),			
		.IncTs		(dIncTs),
		
		.ResetCulSect	(dResetCulSect),	
		.ResetCulPhs	(dResetCulPhs),		
		.ResetRow	(dResetRow),		
		.ResetFrm		(dResetFrm),		
		.ResetTs		(dResetTs),
		
		.Tug2head	(dTug2head),				
		.Tu12Head	(dTu12Head),				
		.Tu12End		(dTu12End),		
		.PlTug2		(dPlTug2),
		
		.CulSect		(dCulSect),				
		.CulPhs		(dCulPhs),	
		.Ts		(dTs),
		.Row		(dRow),					
		.Frm		(dFrm)					
	);	

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////


endmodule


